{% load static %}

<!DOCTYPE html>
<html>

<head>
<title>TMNT Asset Viewer</title>
<link rel="stylesheet" href="{% static 'tmnt.css' %}">
<link rel="icon" href="{% static 'favicon.ico' %}">
</head>



<body>
<!-- Top of screen menu bar -->
<div id = 'menuBar'>
    <h1>Threat Modeling Naturally Tool</h1>
    <div class="topnav">
        <a href="#share">Share</a>
        <a href="#export">Export</a>
        <a href="#profile">Profile</a>
    </div>
</div>

<!-- Everything below the top of the screen -->
<div class="lowerArea">
    <!-- Left sidebar to switch between modes -->
    <div class="modeBar">
        <img src="{% static 'assets.png' %}" width="75%" style="padding-bottom: 10px;" onclick= "showSection('assets')">
        <img src="{% static 'warnings.png' %}" width="75%" style="padding-bottom: 10px;" onclick="showSection('threats')">
        <img src="{% static 'wrench.png' %}" width="75%" style="padding-bottom: 10px;"  onclick="showSection('controls')">
        <img src="{% static 'magnify.png' %}" width="75%" style="padding-bottom: 10px;" onclick="showSection('findings')">
    </div>

    <!-- Area for actually adding assets/threats/controls/etc. -->
    <div id="itemsBar" class="itemsBar">

        <!-- Panel for adding assets -->
        <div id="assets" class="items">
            <h2>What are we working on?</h2>
            <br>

            <h3>Assets</h3>
            <div class="button_container">
                <button type="button" class="asset_button" onclick="addElement(this.innerHTML)">Actor</button>
                <button type="button" class="asset_button" onclick="addElement(this.innerHTML)">Server</button>
                <button type="button" class="asset_button" onclick="addElement(this.innerHTML)">Data Store</button>
            </div>
            <div class="button_container">
                <button type="button" class="asset_button" onclick="addElement(this.innerHTML)">Lambda</button>
                <button type="button" class="asset_button" onclick="addElement(this.innerHTML)">Process</button>
                <button type="button" class="asset_button" onclick="addElement(this.innerHTML)">External Entity</button>
            </div>
            <br>

            <h3>Dataflows</h3>

            <label for="source_dropdown">Source:</label>
            <select name="source_dropdown" class="dropdown" id="source_dropdown" disabled>
                <option value="invalid">Add an asset first!</option>
            </select>

            <br>

            <label for="target_dropdown">Target:</label>
            <select name="target_dropdown" class="dropdown" id="target_dropdown" disabled>
                <option value="invalid">Add an asset first!</option>
            </select>

            <br>
            <button type="button" class="add_button" onclick="addDataFlow(this.innerHTML)" disabled>Add Data Flow</button>

            <br>

            <h3>Workflows</h3>

            <div>Add components in the order in which they occur:</div>
            <div id="adding_workflows">
                <label>1st:</label>
                <select name="component_dropdown" class="dropdown" disabled>
                    <option value="invalid">Add an asset first!</option>
                </select>
            </div>

            <button type="button" class="add_button" id="components_button" onclick="addComponents()" disabled>Add More Components</button>

            <br>
            <button type="button" class="add_button" onclick="addWorkFlow()" disabled>Add Work Flow</button>
        </div>

        <!-- Panel for adding threats -->
        <div id="threats" class="items" style="display: none;">
            <h2>What could go wrong?</h2>
            <br>

            <h3>Threats</h3>
            <div>
            <label for="threat_dropdown">Add to asset:</label>
            <select name="threat_dropdown" id = "threat_dropdown" class="dropdown" disabled>
                <option value="invalid">Add an asset first!</option>
            </select>

            <br>
            <input class="threat_textbox" id="threat_title" type="text" placeholder="Threat title..." name="threat_title">
            <br>

            <input class="threat_textbox" id="threat_number" type="text" placeholder="(Optional) CVE/CWE number" name="threat_number">
            <br>

            <textarea class="threat_textbox" id="threat_description" name="threat_description" placeholder="(Optional) Threat description..."rows="4" cols="20"></textarea>

            <button type="button" class="add_button" onClick = "addThreat()">Add Threat</button></div>
            <br>
            <div id = "added_threats">
                <h3>Potential Threats</h3>
                [[ placeholder text ]]
            </div>
        </div>

        <!-- Panel for adding controls -->
        <div id="controls" class="items" style="display: none;" >
            <h2>What are we doing about it?</h2>
            <br>

            <h3>Controls</h3>
            <div>
            <label for="controls_dropdown">Apply to asset:</label>
            <select name="controls_dropdown" id = "controls_dropdown" class="dropdown" disabled>
                <option value="invalid">Add an asset first!</option>
            </select>
            <br>
            <input class="controls_textbox" id="control_title" type="text" placeholder="Control title..." name="control_title">
            <br>
            <textarea class="controls_textbox" id="control_description" name="threat_description" placeholder="(Optional) Control description..."rows="4" cols="20"></textarea>

            <button type="button" class="add_button" onClick="addControl()">Add Control</button></div>
            <br>
            <div id = "added_controls">
                <h3>Potential Controls</h3>
                [[ placeholder text ]]
            </div>
        </div>

        <!-- Panel for adding and reviewing findings -->
        <div id="findings" class="items" style="display: none;">
            <h2>Did we do a good enough job?</h2>
            <br>

            <h3>Findings</h3>
            <label for="findings_asset_dropdown">Review findings for:</label>
            <select id="findings_asset_dropdown" name="asset_dropdown" onchange="updateThreatDropdown()" id="asset_dropdown" class="dropdown" disabled>
                <option value="-1">Add an asset first!</option>
            </select>
            <br>
            <label for="findings_threats_dropdown">Select a threat:</label>
            <select name="findings_threats_dropdown" id="findings_threats_dropdown" onchange="updateFindings()" disabled>
                <option value="-1">Add an asset first!</option>
            </select>
            <br><br>
            <div id = "greyed_out">
            <div id = "status">
            <label for="status_dropdown">Status:</label>
            <select name="status_dropdown" id="status_dropdown" disabled>
                <option value="-1">Select an asset first!</option>
            </select>
            </div>
            <b>Select mitigating controls:</b>
            <br>
            <div id="control_findings">
                &ensp;<span style="color: grey">Select a threat first!</span>
            </div>
            <div id = "technical_impact">
                <table>
                    <tr>
                        <th style="text-align: left;">Technical impact:</th>
                        <th>None</th>
                        <th>Low</th>
                        <th>High</th>
                    </tr>
                    <tr>
                        <td style="text-align: left;">&emsp;Confidentiality</td>
                        <td><input type="radio" class="tech_impact_radio" name="radio_confidentiality" value="none" disabled></td>
                        <td><input type="radio" class="tech_impact_radio" name="radio_confidentiality" value="low" disabled></td>
                        <td><input type="radio" class="tech_impact_radio" name="radio_confidentiality" value="high" disabled></td>
                    </tr>
                    <tr>
                        <td style="text-align: left;">&emsp;Integrity</td>
                        <td><input type="radio" class="tech_impact_radio" name="radio_integrity" value="none" disabled></td>
                        <td><input type="radio" class="tech_impact_radio" name="radio_integrity" value="low" disabled></td>
                        <td><input type="radio" class="tech_impact_radio" name="radio_integrity" value="high" disabled></td>
                    </tr>
                    <tr>
                        <td style="text-align: left;">&emsp;Availability</td>
                        <td><input type="radio" class="tech_impact_radio" name="radio_availability" value="none" disabled></td>
                        <td><input type="radio" class="tech_impact_radio" name="radio_availability" value="low" disabled></td>
                        <td><input type="radio" class="tech_impact_radio" name="radio_availability" value="high" disabled></td>
                    </tr>
                    <tr>
                        <td style="text-align: left;">&emsp;Authenticity</td>
                        <td><input type="radio" class="tech_impact_radio" name="radio_authenticity" value="none" disabled></td>
                        <td><input type="radio" class="tech_impact_radio" name="radio_authenticity" value="low" disabled></td>
                        <td><input type="radio" class="tech_impact_radio" name="radio_authenticity" value="high" disabled></td>
                    </tr>
                    <tr>
                        <td style="text-align: left;">&emsp;Non-Repudiation</td>
                        <td><input type="radio" class="tech_impact_radio" name="radio_nonrepudiation" value="none" disabled></td>
                        <td><input type="radio" class="tech_impact_radio" name="radio_nonrepudiation" value="low" disabled></td>
                        <td><input type="radio" class="tech_impact_radio" name="radio_nonrepudiation" value="high" disabled></td>
                    </tr>
                    <tr>
                        <td style="text-align: left;">&emsp;Authorization</td>
                        <td><input type="radio" class="tech_impact_radio" name="radio_authorization" value="none" disabled></td>
                        <td><input type="radio" class="tech_impact_radio" name="radio_authorization" value="low" disabled></td>
                        <td><input type="radio" class="tech_impact_radio" name="radio_authorization" value="high" disabled></td>
                    </tr>

                </table>

            </div>
            <div id = "safety_impact">
                <b>Safety impact:</b>
                <br>
                &ensp;<label for="harm_dropdown">Harm:</label>
                    <select id="harm_dropdown" class = "findings_dropdown" disabled>
                    </select><br>
                    &ensp;<label for="exploitability_dropdown">Exploitability:</label>
                    <select id="exploitability_dropdown" class = "findings_dropdown" disabled>
                    </select><br>
                <div id= "datetime"> <b>Assessed on:</b> </div>
                <b>Assessed by:</b> &nbsp<input id="assessor_textbox" type="text" placeholder="Name..." name="assessor">
                <br>
             </div>
             <b>Notes:</b><br><textarea class="notes_textbox" id="notes_textbox" name="notes_textbox" placeholder="(Optional) Add Notes..."rows="4" cols="20"></textarea><br>

             <br>
             <button type="button" class="add_button" onclick="saveFinding()">Save</button disabled>
            </div>
        </div>
    </div>

    <!-- Area to display actual DFD -->
    <div class="dfd_assetview" id="dfd">
        <!-- svg is generated into here -->
        <svg id="dfd_svg"></svg>
        <!-- bottom bar is generated into here -->
        <div class="dfd_detailsbar" id="bottom_bar">        
            <h2 style="color: gray">No asset selected...</h2>
            <br>
            <h2 style="color: gray">Select a Workflow: </h2>
            <select name="workflow_dropdown" class="workflow_dropdown" id="workflow_dropdown" disabled>
                <option value="invalid">Add a workflow first!</option>
            </select>
            <button type="button" class="view_button" id="view_button" onclick="viewWorkflow()" disabled>View</button>
        </div>
    </div>
</div>

<!-- JavaScript code starts here -->
<script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
<script>
    // Static variables
    var nodes = [];
    var total_nodes = 0;
    var links = [];
    var workflows = {};
    var svg;
    var simulation;

    // Create an SVG on page load
    window.onload = function() {
        var date = new Date();
        var displayDate = date.toLocaleDateString();
        var displayTime = date.toLocaleTimeString();
        document.getElementById('datetime').innerHTML += displayDate + " " + displayTime;

        let area = d3.select('.dfd_assetview').node().getBoundingClientRect();

        svg = d3.select('#dfd_svg')
        .attr("width", area.width)
        .attr("height", area.height * 0.75); // TODO make this dynamic with bottom bar

        // Tells d3 how to handle forces
        simulation = d3.forceSimulation(nodes)
        .force("x", d3.forceX(area.width / 2))
        .force("y", d3.forceY(area.height / 2 * 0.75)) // TODO make this dynamic with bottom bar
        .force("collide", d3.forceCollide().radius(100))
        .on("tick", ticked);

        // Creates a definition for an arrowhead, to be used by links later
        svg.append("defs")
        .append("marker")
        .attr("id", "arrow")
        .attr("markerWidth", 20)
        .attr("markerHeight", 20)
        .attr("refX", 20 - 1)
        .attr("refY", 10)
        .attr("orient", "auto")
        .attr("markerUnits", "strokeWidth")
        .append("path")
        .attr("d", 'M 0,0 L 20,10 L 0,20 z')
        .attr("fill", "#000");

        // unselects node(s) if you click on canvas
        svg.on("click", function (e) {
            if (e.target.id == "dfd_svg") {
                // Unselect all nodes
                for (let node of nodes) {
                    node.selected = false;
                }
                d3.selectAll(".asset")
                    .style("stroke", "black")
                    .style("stroke-width", "1");
                resetBottomBar();
            }
        })
    }

    // On window resize, run the force simulation again
    // so that elements don't ever get stuck off screen
    window.onresize = function() {
        // FIXME: Sometimes, AFTER resizing the screen, adding a new element
        // causes it to get stuck in the corner with an error complaining that
        // it is being transformed to NaN coordinates.
        // This seems to fix itself after another resize or two, and also seems
        // more common when the window is particularly small.
        // Why is this happening!?!?

        let area = d3.select('.dfd_assetview').node().getBoundingClientRect();

        svg = d3.select('#dfd_svg')
        .attr("width", area.width)
        .attr("height", area.height * 0.75); // TODO make this dynamic with bottom bar

        simulation = d3.forceSimulation(nodes)
        .force("x", d3.forceX(area.width / 2))
        .force("y", d3.forceY(area.height / 2 * 0.75)) // TODO make this dynamic with bottom bar
        .force("collide", d3.forceCollide().radius(100))
        .on("tick", ticked);

        simulation.alpha(1.0).restart();
    }

    // Toggles between the four question sections (What are we working on?, etc.)
    // Determines which one should be displayed.
    function showSection(icon) {
        var divs = document.querySelectorAll('.items');
        divs.forEach(div => {
            div.style.display = "none";
        });
        document.getElementById(icon).style.display = "block";

        // Prevent user from trying to add a threat or a control if no
        // assets exist yet in the DFD
        if (icon == "threats") {
            let elems = document.getElementsByClassName('threat_textbox');
            for (let elem of elems) {
                elem.disabled = (nodes.length == 0);
            }
        }
        else if (icon == "controls") {
            let elems = document.getElementsByClassName('controls_textbox');
            for (let elem of elems) {
                elem.disabled = (nodes.length == 0);
            }
        }
        let elems = document.getElementsByClassName('add_button');
        for (let elem of elems) {
            elem.disabled = (nodes.length == 0);
        }

        // Recalculate dropdowns when findings tab is opened
        if (icon == "findings") {
            updateThreatDropdown();
        }
    }

    // When an Asset button is clicked, this function creates a corresponding
    // node, then pushes it to the list of nodes for d3 to draw at a later step.
    function addElement(asset_type) {
        // Prompt user for asset name
        let area = d3.select('.dfd_assetview').node().getBoundingClientRect();

        var asset_name = window.prompt("Name this object:", "New " + asset_type);
        if (asset_name == null)
            return;

        // Add new node to nodes array
        let rand_x = area.width/2 + Math.random()*5 - 10;
        let rand_y = area.height/2 + Math.random()*5 - 10;
        nodes.push({
            "id": total_nodes,
            "asset_type": asset_type,
            "asset_name": asset_name,
            'x': rand_x,
            'y': rand_y,
            "threats": [],
            "controls": [],
            "selected": false
        })
        total_nodes++;

        // Select every node and attach it to an asset
        var node_update = svg.selectAll(".node_group")
            .data(simulation.nodes(), function (d) {return d.id});

        // node.enter() gets every NEWLY ADDED node.
        // For each of these, append a node_group g to the new node...
        let node_group = node_update.enter().append("g")
            .on("click", clicked)
            .attr("class", "node_group")
            .call(d3.drag().on("drag", dragged));
            // TODO maybe add a dragend that selects the node if the drag is tiny?
            // that way small drags are still registered as clicks for selection

        // ...attach a shape to that group...
        // (big switch statement to decide the proper shape for asset_type)
        switch (asset_type) {
            case "Actor":
                node_group
                .append('rect')
                .attr('class', 'asset')
                .attr('x', -30)
                .attr('y', -30)
                .attr('width', 60)
                .attr('height', 60)
                .style('fill', 'white')
                .style('stroke', 'black');
                break;
            case "Server":
                node_group
                .append('rect')
                .attr('class', 'asset')
                .attr('x', -30)
                .attr('y', -30)
                .attr('width', 60)
                .attr('height', 60)
                .style('fill', 'white')
                .style('stroke', 'black');
                break;
            case "Data Store":
                let radX = 30;
                let radY = 15;

                node_group
                .append('rect')
                .attr('class', 'asset')
                .attr('x', 0 - radX)
                .attr('y', -1.5*radY)
                .attr('width', radX*2)
                .attr('height', radY*3)
                .style('fill', 'white')
                .style('stroke', 'black');

                node_group
                .append('ellipse')
                .attr('class', 'asset')
                .attr('cx', 0)
                .attr('cy', -1.5*radY)
                .attr('rx', radX)
                .attr('ry', radY)
                .style('fill', 'white')
                .style('stroke', 'black');

                node_group
                .append('ellipse')
                .attr('class', 'asset')
                .attr('cx', 0)
                .attr('cy', 1.5*radY)
                .attr('rx', radX)
                .attr('ry', radY)
                .style('fill', 'white')
                .style('stroke', 'black');
                break;
            case "Process":
                node_group
                .append('circle')
                .attr('class', 'asset')
                .attr('cx', 0)
                .attr('cy', 0)
                .attr('r', 30)
                .style('fill', 'white')
                .style('stroke', 'black');
                break;
            case "External Entity":
                node_group
                .append('rect')
                .attr('class', 'asset')
                .attr('x', -30)
                .attr('y', -30)
                .attr('width', 60)
                .attr('height', 60)
                .style('fill', 'white')
                .style('stroke', 'black');
                break;
            case "Lambda":
                node_group
                .append('text')
                .attr('class', 'asset')
                .attr('x', -25)
                .attr('y', 40)
                .attr('fill', 'white')
                .style('stroke', 'black')
                .style("font-size", '100pt')
                .style('font-family', 'Calibri')
                .text('Î»');
                break;
            case "Trust Boundry":
                node_group
                .append('rect')
                .attr('class', 'asset')
                .attr('x', 0)
                .attr('y', 0)
                .attr('width', 60)
                .attr('height', 60)
                .style('fill', 'white')
                .attr('stroke-dasharray','5,3')
                .style('stroke', 'black');
                break;
            default:
                // should never happen
                console.debug("ERROR: addElement() got name " + name + ", which isn't recognized as a shape");
                break;
        }

        // ...and attach name of asset, provided by user to that group
        node_group
            .append("text")
            .attr("class", "asset_label")
            .attr("x", 15)
            .attr("y", 15)
            .attr("text-anchor", "middle")
            .attr("alignment-baseline", "central")
            .attr("fill", "black")
            .style("font-size", "16pt")
            .text(asset_name);

        // force nodes to start in the center of the canvas
        node_group
            .attr("transform", "translate(" + area.width/2 + "," + area.height/2 + ")")

        // Also, remove any duplicate nodes.
        node_update.exit().remove();

        // Last, (re)run the force simulation
        simulation.nodes(nodes);
        simulation.alpha(1.0).restart();

        updateAssetDropdowns();

        // Update list of nodes in options dropdown
        if (document.getElementById("options")) {
            var curr_asset = document.getElementById("options").children[0].value;
            document.getElementById("add_dataflow").replaceChild(createDataflowList(curr_asset), document.getElementById("dataflow_button"));
        }
    }

    // gives nodes new location every time the force simulation runs
    function ticked() {
        // Transform links
        svg.selectAll(".link")
            .attr("x1", function(d) { return d.source.x; })
            .attr("y1", function(d) { return d.source.y; })
            .attr("x2", function(d) { return d.target.x; })
            .attr("y2", function(d) { return d.target.y; });

        // Transform nodes
        svg.selectAll(".node_group")
            .attr("transform", function(d) { return "translate("+ d.x + "," + d.y + ")"; });

        // Transform dataflows
        svg.selectAll(".link_group").selectAll("text")
            .attr("transform", function(d) { return "translate("+ (d.source.x + d.target.x)/2 + "," + (d.source.y + d.target.y)/2 + ")"; });
    }

    // Function that defines how node groups should behave when dragged.
    function dragged(e) {
        e.subject.x = e.x;
        e.subject.y = e.y;
        simulation.alpha(1.0).restart();
    }

    // Function that defines how node groups should behave when clicked.
    function clicked(e) {
        let selected_node = d3.select(this).data()[0]
        let already_selected = selected_node.selected;

        // Unselect all nodes
        for (let node of nodes) {
            node.selected = false;
        }
        d3.selectAll(".asset")
            .style("stroke", "black")
            .style("stroke-width", "1");
            
        // Reselect the clicked on node
        selected_node.selected = !already_selected;
        if (!already_selected) {
            d3.select(this).selectAll(".asset")
                .style("stroke", "#3E8EDE")
                .style("stroke-width", "4");

            bottom_bar_html =
                "<ul class=\"options\" id=\"options\"><li value=\"" + selected_node.id + "\"><a href=\"#\">Options &#9662;</a><ul></ul></li></ul>" + 
                "<h2>" + selected_node.asset_name + "</h2>" + 
                selected_node.asset_type +
                "<br><br>" +
                "<h3>Threats</h3>";

            if (selected_node.threats.length == 0) {
                bottom_bar_html += "No threats added...<br>"
            } else {
                for (let threat of selected_node.threats) {
                    bottom_bar_html += "&emsp;&emsp;" +
                    threat.threat_title + " ("+ threat.threat_num + ")" + "<br>";
                }
            }

            bottom_bar_html += "<br><h3>Controls</h3>"
            if (selected_node.controls.length == 0) {
                bottom_bar_html += "No controls added...<br>"
            } else {
                for (let control of selected_node.controls) {
                    bottom_bar_html +=
                        control.control_title + "<br>";
                }
            }
        }

        // places information about the selected node in the bottom bar
        document.getElementById("bottom_bar").innerHTML = bottom_bar_html;

        // create the options button for the asset
        createAssetOptions();
    }

    // Helper function that gets the value of an HTML dropdown given
    // its ID in the HTML document.
    function getDropdownValue(html_id) {
        let dropdown = document.getElementById(html_id);
        let value = parseInt(dropdown.options[dropdown.selectedIndex].value);
        return value;
    }

    // Helper function that finds the index of an asset in the nodes array 
    // given the asset's id 
    function nodeIndex(node_id) {
        return nodes.findIndex(i => i.id == node_id);
    }

    // Resets the bottom details bar to default state (nothing selected)
    function resetBottomBar() {
        document.getElementById("bottom_bar").innerHTML =
        "<h2 style=\"color: gray\">No asset selected...</h2>" 
        + "<br>" 
        + "<h2 style=\"color: gray\">Select a Workflow: </h2>" 
        + "<select name=\"workflow_dropdown\" class=\"workflow_dropdown\" id=\"workflow_dropdown\" disabled>" 
        + "<option value=\"invalid\">Add a workflow first!</option>" 
        + "</select>"
        + "<button type=\"button\" class=\"view_button\" id=\"view_button\" onclick=\"viewWorkflow()\" disabled>View</button>";
        updateWorkflowDropdown();
    }

    // Create the options dropdown button when viewing an asset
    function createAssetOptions() {
        var assetID = document.getElementById("options").children[0].value;
        var options = document.getElementById("options").children[0].children[1];

        // creating the button to add new dataflows to the current asset
        var listItem = document.createElement('li');
        listItem.id = "add_dataflow";
        var new_dataflow = document.createElement('a');
        new_dataflow.href = "#";
        new_dataflow.innerHTML = "Create dataflow to...";
        new_dataflow.onclick = function () {
            if (nodes.length < 2) {
                alert("Add more assets first!")
            }
        }
        listItem.appendChild(new_dataflow);
        listItem.appendChild(createDataflowList(assetID));
        options.appendChild(listItem);

        // creating the button to view workflows connected to current asset
        listItem = document.createElement('li');
        listItem.id = "view_workflow";
        var view_workflow = document.createElement('a');
        view_workflow.href = "#";
        view_workflow.innerHTML = "View workflow...";
        view_workflow.onclick = function() {
            var has_workflows = false;
            for (let components of Object.values(workflows)) {
                if (components.includes(assetID)) {
                    has_workflows = true;
                }
            }
            if (!has_workflows) {
                alert("There are no workflows with this asset!");
            }
        }
        listItem.appendChild(view_workflow);
        listItem.appendChild(createWorkflowList(assetID));
        options.appendChild(listItem);

        // creating nested delete dropdown menu
        listItem = document.createElement('li');
        var delete_button = document.createElement('a')
        delete_button.href = "#";
        delete_button.innerHTML = "Delete...";
        listItem.appendChild(delete_button);
        var delete_list = document.createElement('ul');

        // creating button for deleting threats
        var threat_li = document.createElement('li');
        var remove_threat = document.createElement('a');
        remove_threat.href = "#";
        remove_threat.innerHTML = "Threat...";
        remove_threat.onclick = function() {
            var threats = nodes[nodeIndex(assetID)].threats;
            if (threats.length == 0) {
                alert("There are no threats added to this asset!");
                return;
            }
            var ul = document.getElementById("options");
            ul.style.display = "none";
            
            // creating the checklist to select threats to delete
            var new_ul = document.createElement("ul");
            new_ul.style.background = "#f3f3f3";
            new_ul.style.borderRadius = "20px";
            new_ul.style.padding = "10px";
            new_ul.style.width = "fit-content";
            new_ul.style.float = "right";
            var new_div = document.createElement("div");
            new_div.innerHTML = "Select threats to be deleted:";
            new_ul.appendChild(new_div);
            for (let threat of threats) {
                let new_li = document.createElement("li");
                let new_label = document.createElement("label");
                new_label.innerHTML = threat.threat_title + " ("+ threat.threat_num + ")";
                let new_input = document.createElement("input");
                new_input.classList.add("flowChecks");
                new_input.type = "checkbox";
                new_label.appendChild(new_input);
                new_li.appendChild(new_label);
                new_ul.appendChild(new_li);
            }
            var submit = document.createElement("button");
            submit.innerHTML = "Done"
            var bar = document.getElementById("bottom_bar");
            submit.onclick = function () {
                var flow_checks = document.getElementsByClassName("flowChecks");
                for (let i = flow_checks.length - 1; i >= 0; i--) {
                    if (flow_checks[i].checked) {
                        threats.splice(i, 1);
                    }
                }
                nodes[nodeIndex(assetID)].threats = threats;
                let options = document.getElementById("options")
                options.style.display = "block"; 
                svg.selectAll(".node_group").filter(d => d.id === assetID).dispatch('click').dispatch('click');
            }
            new_ul.appendChild(document.createElement("br"));
            new_ul.appendChild(submit);
            new_ul.style.display = "block";
            bar.insertBefore(new_ul, bar.children[0]);
        }
        threat_li.appendChild(remove_threat);
        delete_list.appendChild(threat_li);

        // creating button for deleting controls
        var control_li = document.createElement('li');
        var remove_control = document.createElement('a');
        remove_control.href = "#";
        remove_control.innerHTML = "Control...";
        remove_control.onclick = function() {
            var controls = nodes[nodeIndex(assetID)].controls;
            if (controls.length == 0) {
                alert("There are no controls added to this asset!");
                return;
            }
            var ul = document.getElementById("options");
            ul.style.display = "none";
            
            // creating checklist to select controls to delete
            var new_ul = document.createElement("ul");
            new_ul.style.background = "#f3f3f3";
            new_ul.style.borderRadius = "20px";
            new_ul.style.padding = "10px";
            new_ul.style.width = "fit-content";
            new_ul.style.float = "right";
            var new_div = document.createElement("div");
            new_div.innerHTML = "Select controls to be deleted:";
            new_ul.appendChild(new_div);
            for (let control of controls) {
                let new_li = document.createElement("li");
                let new_label = document.createElement("label");
                new_label.innerHTML = control.control_title;
                let new_input = document.createElement("input");
                new_input.classList.add("flowChecks");
                new_input.type = "checkbox";
                new_label.appendChild(new_input);
                new_li.appendChild(new_label);
                new_ul.appendChild(new_li);
            }
            var submit = document.createElement("button");
            submit.innerHTML = "Done"
            var bar = document.getElementById("bottom_bar");
            submit.onclick = function () {
                var flow_checks = document.getElementsByClassName("flowChecks");
                for (let i = flow_checks.length - 1; i >= 0; i--) {
                    if (flow_checks[i].checked) {
                        controls.splice(i, 1);
                    }
                }
                nodes[nodeIndex(assetID)].controls = controls;
                let options = document.getElementById("options")
                options.style.display = "block"; 
                svg.selectAll(".node_group").filter(d => d.id === assetID).dispatch('click').dispatch('click');
            }
            new_ul.appendChild(document.createElement("br"));
            new_ul.appendChild(submit);
            new_ul.style.display = "block";
            bar.insertBefore(new_ul, bar.children[0]);
        }
        control_li.appendChild(remove_control);
        delete_list.appendChild(control_li);

        // creating button for deleting dataflows
        flow_li = document.createElement('li');
        var remove_flow = document.createElement('a');
        remove_flow.href = "#";
        remove_flow.innerHTML = "Dataflow...";
        remove_flow.onclick = function() {
            var flows = [];
            for (let i = 0; i < links.length; i++) {
                if (links[i].source.id == assetID || links[i].target.id === assetID) {
                    flows.push(i);
                }
            }
            if (flows.length == 0) {
                alert("There are no dataflows connected to this asset!");
                return;
            }
            var ul = document.getElementById("options");
            ul.style.display = "none";
            var new_ul = document.createElement("ul");
            new_ul.style.background = "#f3f3f3";
            new_ul.style.borderRadius = "20px";
            new_ul.style.padding = "10px";
            new_ul.style.width = "fit-content";
            new_ul.style.float = "right";
            var new_div = document.createElement("div");
            new_div.innerHTML = "Select data flows to be deleted:";
            new_ul.appendChild(new_div);
            for (let flow of flows) {
                let new_li = document.createElement("li");
                let new_label = document.createElement("label");
                new_label.innerHTML = links[flow].source.asset_name + " &#8594 " + links[flow].target.asset_name;
                let new_input = document.createElement("input");
                new_input.classList.add("flowChecks");
                new_input.type = "checkbox";
                new_label.appendChild(new_input);
                new_li.appendChild(new_label);
                new_ul.appendChild(new_li);
            }
            var submit = document.createElement("button");
            submit.innerHTML = "Done"
            var bar = document.getElementById("bottom_bar");
            submit.onclick = function () {
                if (!confirm("This will delete all workflows that include the selected dataflows. Continue?")) {
                    return;
                }
                var flow_checks = document.getElementsByClassName("flowChecks");

                // Find and remove connected workflows
                var removed_workflows = false;
                for (let i = 0; i < flows.length; i++) {
                    if (flow_checks[i].checked) {
                        var source = links[flows[i]].source.id;
                        var target = links[flows[i]].target.id;
                        for (let key of Object.keys(workflows)) {
                            var components = workflows[key];
                            if (components.includes(source) && components.indexOf(source) == components.indexOf(target) - 1) {
                                removed_workflows = true;
                                delete workflows[key];
                            }
                        }
                    }
                }
                if (removed_workflows) {
                    document.getElementById("view_workflow").replaceChild(createWorkflowList(assetID), document.getElementById("workflow_button"));
                }

                // Remove selected dataflows
                for (let i = flows.length - 1; i >= 0; i--) {
                    if (flow_checks[i].checked) {
                        links.splice(flows[i], 1);
                    }
                }
                var link_update = svg.selectAll(".link_group").data(links, function(d) { return d.source.id + "-" + d.target.id; });
                link_update.exit().remove();

                let options = document.getElementById("options")
                options.style.display = "block";
                bar.removeChild(bar.children[0]);                   
            }
            new_ul.appendChild(document.createElement("br"));
            new_ul.appendChild(submit);
            new_ul.style.display = "block";
            bar.insertBefore(new_ul, bar.children[0]);
        }
        flow_li.appendChild(remove_flow);
        delete_list.appendChild(flow_li);

        // creating button to delete current asset
        var asset_li = document.createElement('li');
        var del = document.createElement('a');
        del.href = "#";
        del.innerHTML = "Asset";
        del.onclick = function() {
            if (!confirm("This will delete all dataflows and workflows connected to this asset. Continue?")) {
                return;
            }
            nodes.splice(nodeIndex(assetID), 1);
            svg.selectAll(".node_group").each(function (d) {
                if (assetID == d.id) {
                    d3.select(this).remove();
                }
            });
            updateAssetDropdowns();

            // removing all dataflows connected to this asset
            for (let i = 0; i < links.length; i++) {
                if (links[i].source.id == assetID || links[i].target.id === assetID) {
                    links.splice(i, 1);
                    i--;
                }
            }
            var link_update = svg.selectAll(".link_group").data(links, function(d) { return d.source.id + "-" + d.target.id; });
            link_update.exit().remove();

            // removing all workflows connected to this asset
            for (let key of Object.keys(workflows)) {
                if (workflows[key].includes(assetID)) {
                    delete workflows[key];
                }
            }
            resetBottomBar();
        }
        asset_li.appendChild(del);
        delete_list.appendChild(asset_li);
        listItem.appendChild(delete_list);
        options.appendChild(listItem);
    }

    // Helper function to create/update list of possible new dataflows in   
    // options dropdown menu
    function createDataflowList(assetID) {
        var dataflow_list = document.createElement('ul');
        dataflow_list.id = "dataflow_button";
        for (let node of nodes) {
            if (node.id == assetID) {
                continue;
            }
            var node_li = document.createElement('li');
            var node_a = document.createElement('a');
            node_a.href = "#";
            node_a.innerHTML = node.asset_name;
            node_a.onclick = function() {
                let dropdowns = document.getElementsByClassName('dropdown');
                dropdowns[0].selectedIndex = nodeIndex(assetID) + 1;
                dropdowns[1].selectedIndex = nodes.indexOf(node) + 1;
                addDataFlow();
            }
            node_li.appendChild(node_a);
            dataflow_list.appendChild(node_li);
        }
        return dataflow_list;
    }

    // Helper function to create/update list of workflows to view in options 
    // dropdown menu
    function createWorkflowList(assetID) {
        var workflow_keys = [];
        for (let name of Object.keys(workflows)) {
            if (workflows[name].includes(assetID)) {
                workflow_keys.push(name);
            }
        }
        var workflow_list = document.createElement('ul');
        workflow_list.id = "workflow_button";
        for (let key of workflow_keys) {
            var node_li = document.createElement('li');
            var node_a = document.createElement('a');
            node_a.href = "#";
            node_a.innerHTML = key;
            node_a.onclick = function() {
                resetBottomBar();
                document.getElementById("workflow_dropdown").selectedIndex = Object.keys(workflows).indexOf(key) + 1;
                viewWorkflow();
            }
            node_li.appendChild(node_a);
            workflow_list.appendChild(node_li);
        }
        return workflow_list;
    }

    // Clears the workflow dropdown list, then regenerates them
    // with the names of every existing element
    function updateWorkflowDropdown() {
        let workflow_dropdown = document.getElementById("workflow_dropdown");
        let view_button = document.getElementById("view_button");

        while (workflow_dropdown.options.length > 0) {
            workflow_dropdown.remove(0);
        }

        if (Object.keys(workflows).length == 0) {
            workflow_dropdown.add(new Option("Add a workflow first!", -1));
            workflow_dropdown.disabled = true;
            view_button.disabled = true;
        }
        else {
            workflow_dropdown.add(new Option("Select a workflow...", -1));
            workflow_dropdown.disabled = false;
            view_button.disabled = false;
            var workflow_names = Object.keys(workflows);
            for (let workflow_name of workflow_names) {
                workflow_dropdown.add(new Option(workflow_name));
            }
        }
    }

    // Clears the asset dropdown lists, then regenerates them
    // with the names of every existing element
    function updateAssetDropdowns() {
        let dropdowns = document.getElementsByClassName('dropdown');

        while (dropdowns[0].options.length > 0) {
            for (let dropdown of dropdowns) {
                dropdown.remove(0);
            }
        }

        let elems = document.getElementsByClassName('add_button');
        for (let elem of elems) {
            elem.disabled = (nodes.length == 0);
        }

        if (nodes.length != 0) {
            for (let dropdown of dropdowns) {
                dropdown.disabled = false;
                dropdown.selectedIndex = 0;
                dropdown.add(new Option("Select an asset...", -1));
            }
        }
        else {
            for (let dropdown of dropdowns) {
                dropdown.disabled = true;
                dropdown.add(new Option("Add an asset first!", -1));
            }
            return;
        }

        const svg = d3.select(document.getElementById("dfd")).select("svg");
        svg.selectAll(".node_group").each(function (d, i) {
            for (let dropdown of dropdowns) {
                dropdown.add(new Option(
                    d3.select(this).select(".asset_label").text(),
                    nodeIndex(d.id)
                ))
            }
        });
    }

    // Clears the threat dropdown lists, then regenerates them
    // with the names of every existing element
    function updateThreatDropdown() {
        let threat_dropdown = document.getElementById("findings_threats_dropdown");
        let node_id = getDropdownValue("findings_asset_dropdown");
        threat_dropdown.disabled = true;

        while (threat_dropdown.options.length > 0) {
            threat_dropdown.remove(0);
        }

        if (nodes.length == 0) {
            threat_dropdown.add(new Option("Add an asset first!", -1));
        }
        else if (node_id == -1) {
            threat_dropdown.add(new Option("Select an asset first!", -1));
        }
        else if (nodes[node_id].threats.length == 0) {
            threat_dropdown.add(new Option("No threats on this asset", -1));
        }
        else {
            threat_dropdown.add(new Option("Select a threat...", -1));
            threat_dropdown.disabled = false;
        }

        updateFindings();
        if (threat_dropdown.disabled) {
            document.getElementById("greyed_out").style.setProperty("color", "grey")
            return;
        }

        let i = 0;
        for (let threats of nodes[node_id].threats) {
            threat_dropdown.add(new Option(threats.threat_title, i));
            i++;
        }
    }

    // helper function that fills out dropdowns in the Did we do a good enough
    // job? tab
    function populateSelects(status_dropdown, harm_dropdown, exploitability_dropdown) {
        status_dropdown.disabled = false;
        status_dropdown.add(new Option("Open", 0));
        status_dropdown.add(new Option("Resolved", 1));
        status_dropdown.add(new Option("Not Relevant", 2));

        harm_dropdown.disabled = false;
        harm_dropdown.add(new Option("Negligible", 0));
        harm_dropdown.add(new Option("Minor", 1));
        harm_dropdown.add(new Option("Serious", 2));
        harm_dropdown.add(new Option("Critical", 3));
        harm_dropdown.add(new Option("Catastrophic", 4));

        exploitability_dropdown.disabled = false;
        exploitability_dropdown.add(new Option("Unknown", 0));
        exploitability_dropdown.add(new Option("Low", 1));
        exploitability_dropdown.add(new Option("Medium", 2));
        exploitability_dropdown.add(new Option("High", 3));
    }

    // function changes the list of controls depending on which asset and
    // threat are selected in the Did we do a good enough job? tab
    // also greys out findings tab if an asset and threat have not been
    // selected yet
    function updateFindings() {
        // Get various HTML elements
        let node_id = getDropdownValue("findings_asset_dropdown");
        let selected_threat = getDropdownValue("findings_threats_dropdown");

        let controls_div = document.getElementById("control_findings");
        let status_dropdown = document.getElementById("status_dropdown");
        let harm_dropdown = document.getElementById("harm_dropdown");
        let exploitability_dropdown = document.getElementById("exploitability_dropdown");
        let radio_buttons = document.getElementsByClassName("tech_impact_radio");
        let assessor_textbox = document.getElementById("assessor_textbox");
        let notes_textbox = document.getElementById("notes_textbox")

        // Clear all of the dropdowns and disable all of the buttons
        while (status_dropdown.options.length > 0) {
            status_dropdown.remove(0);
        }
        while (harm_dropdown.options.length > 0) {
            harm_dropdown.remove(0);
        }
        while (exploitability_dropdown.options.length > 0) {
           exploitability_dropdown.remove(0);
        }
        status_dropdown.disabled = true;
        harm_dropdown.disabled = true;
        exploitability_dropdown.disabled = true;
        for (let rb of radio_buttons) {
            rb.checked = false;
            rb.disabled = true;
        }
        assessor_textbox.disabled = true;
        assessor_textbox.value = "";
        notes_textbox.disabled = true;
        notes_textbox.value = "";

        controls_div.innerHTML = "";

        // If we haven't selected an asset:
        if (node_id == -1) {
            // Disable everything, report correct error text
            controls_div.innerHTML = "&ensp;<span style=\"color: grey\">Select an asset first!</span>";
            status_dropdown.add(new Option("Select an asset first!", -1));
            harm_dropdown.add(new Option("Select an asset first!", -1));
            exploitability_dropdown.add(new Option("Select an asset first!", -1));
            document.getElementById("greyed_out").style.setProperty("color", "grey");
            return;
        }
        // Otherwise, if we've selected an asset but not a threat:
        else if (nodes[node_id].threats.length == 0 || selected_threat == -1) {
            // Disable everything, report correct error text
            controls_div.innerHTML = "&ensp;<span style=\"color: grey\">Select a threat first!</span>";
            status_dropdown.add(new Option("Select a threat first!", -1));
            harm_dropdown.add(new Option("Select an threat first!", -1));
            exploitability_dropdown.add(new Option("Select an threat first!", -1));
            document.getElementById("greyed_out").style.setProperty("color", "grey");
            return;
        }
        // Otherwise, if an asset and threat are selected, but no controls
        // exist on the asset:
        else if (nodes[node_id].controls.length == 0) {
            // Enable everything except the controls section,
            // and report correct error text
            controls_div.innerHTML = "&ensp;<span style=\"color: grey\">No controls for this asset</span>";

            populateSelects(status_dropdown, harm_dropdown, exploitability_dropdown);
            for (let rb of radio_buttons) {
                rb.disabled = false;
            }
            assessor_textbox.disabled = false;
            notes_textbox.disabled = false;
            document.getElementById("greyed_out").style.setProperty("color", "black");
        }
        else {
            // Otherwise: Enable everything
            populateSelects(status_dropdown, harm_dropdown, exploitability_dropdown);
            for (let rb of radio_buttons) {
                rb.disabled = false;
            }
            assessor_textbox.disabled = false;
            notes_textbox.disabled = false;
            document.getElementById("greyed_out").style.setProperty("color", "black");

            // Since controls exist, create a checkbox for each one
            let i = 0;
            for (let control of nodes[node_id].controls) {
                let title = control.control_title
                controls_div.innerHTML +=
                    "&emsp;<input type=\"checkbox\" id=\"control_"+ i +"_checkbox\" name=\"control_checkbox\" value=\""+ title +"\"><label for=\"control_" + i + "_checkbox\">" + title + "</label><br>";
                i++;
            }
        }

        // If we previously set and saved a finding for this threat, then load
        // any previously saved values and show them back to the user
        findings = nodes[node_id].threats[selected_threat].findings;
        if (findings != null) {
            assessor = document.getElementById("assessor_textbox");
            assessment_date = document.getElementById("datetime");
            let date = findings.assessment_date;
            let displayDate = date.toLocaleDateString();
            let displayTime = date.toLocaleTimeString();
            notes_textbox = document.getElementById("notes_textbox");

            status_dropdown.selectedIndex = findings.status;
            exploitability_dropdown.selectedIndex = findings.exploitability;
            harm_dropdown.selectedIndex = findings.exploitability;
            assessor.value = findings.assessor;
            assessment_date.innerHTML = "<b>Assessed on:</b> " + displayDate + " " + displayTime;
            notes_textbox.value = findings.notes;

            document.querySelector("input[name=\"radio_confidentiality\"][value=\"" + findings.technical_impact.confidentiality + "\"]").checked = true;
            document.querySelector("input[name=\"radio_integrity\"][value=\"" + findings.technical_impact.integrity + "\"]").checked = true;
            document.querySelector("input[name=\"radio_availability\"][value=\"" + findings.technical_impact.availability + "\"]").checked = true;
            document.querySelector("input[name=\"radio_authenticity\"][value=\"" + findings.technical_impact.authenticity + "\"]").checked = true;
            document.querySelector("input[name=\"radio_nonrepudiation\"][value=\"" + findings.technical_impact.nonrepudiation + "\"]").checked = true;
            document.querySelector("input[name=\"radio_authorization\"][value=\"" + findings.technical_impact.authorization + "\"]").checked = true;

            checked_boxes = findings.controls
            for (i = 0; i < checked_boxes.length; ++i) {
               control = document.getElementById(checked_boxes[i].id)
               control.checked = "checked";
            }
        }

    }

    // Adds a dataflow line between two chosen elements.
    function addDataFlow() {
        // Get the currently selected assets to draw a dataflow between.
        let source = getDropdownValue("source_dropdown");
        let target = getDropdownValue("target_dropdown");
        let double_headed = false

        // Check that user actually has two assets selected:
        if (source == -1 || target == -1) {
            alert("Please select two assets to create a dataflow between!");
            return;
        }

        // Prevent dataflows from being added that point
        // from an object to itself
        if (source === target) {
            alert("Cannot add a dataflow with identical source and target!");
            return;
        }

        for (let link of links) {
            // Prevent duplicate dataflows
            if (link.source.id === nodes[source].id && link.target.id === nodes[target].id) {
                alert("Cannot add a duplicate dataflow!");
                return;
            }
            else if (link.source.id === nodes[target].id && link.target.id === nodes[source].id) {
                double_headed = true
            }
        }

        // Prompt user for dataflow name...
        var dataflow_name = window.prompt("(Optional) Name this dataflow:", "");
        // Return from function if user cancels
        if (dataflow_name === null || dataflow_name === false)
            return;

        // Define the link that d3 will use to apply forces...
        let link = {
            "source": nodes[source],
            "target": nodes[target],
            "type": "Test -->",
            "distance": 30
        }
        // ...and append it to our array of links
        links.push(link);

        // Then, get a selection containing the changes to links from this step
        var link_update = svg.selectAll(".link").data(links,
        function(d) { return d.source.id + "-" + d.target.id; });

        // Use that selection to get the newly added link,
        // and create a group to add the link
        var link_group = link_update.enter()
        .append("g")
        .attr("class", "link_group")

        // Append a line to that group...
        link_group
            .insert("line", ".node") // "insert a line into the SVG right before each .node in the SVG"
            .attr("class", "link")
            .attr("stroke", "black")
            .attr("marker-end", "url(#arrow)")
            .attr("markerWidth", 300)

        // ...as well as a name, if one was given
        if (dataflow_name != null) {
            link_group
                .append("text")
                .attr("x", 35)
                .attr("y", (double_headed) ? 35 : 15) // In case of double-headed dataflow, push second label down
                               // TODO: probably can make this look much cleaner
                .attr("text-anchor", "middle")
                .attr("alignment-baseline", "central")
                .attr("fill", "black")
                .style("font-size", "16pt")
                .text(dataflow_name);
        }

        // Remove any links that need to be removed
        link_update.exit().remove();

        // Last, tell our simulation to restart
        simulation.alpha(1.0).restart();
    }

    // Defines the process of adding components to create a new workflow 
    function addComponents() {
        if (links.length < 1) {
            alert("Please add a data flow first!");
            return;
        }
        var comp_buttons = document.getElementsByName("component_dropdown");
        
        // Remove the button next to the last asset dropdown
        if (comp_buttons.length > 1) {
            let toRemove = document.getElementById("remove_button");
            if (toRemove != null) { toRemove.remove() };
        }

        // Create the new div to be appended to the existing dropdowns
        var newDiv = document.createElement('div');
        newDiv.classList.add("component_div");

        // Create the label for the next selection
        var label = document.createElement('label');
        var ordinal = comp_buttons.length + 1;
        if (ordinal % 10 == 1 && ordinal % 100 != 11) {
            ordinal += "st:";
        }
        else if (ordinal % 10 == 2 && ordinal % 100 != 12) {
            ordinal += "nd:";
        }
        else if (ordinal % 10 == 3 && ordinal % 100 != 13) {
            ordinal += "rd:";
        }
        else {
            ordinal += "th:";
        }
        label.innerHTML = ordinal;
        newDiv.appendChild(label);

        // Create the next asset dropdown 
        var componentsDropdown = document.createElement('select');
        componentsDropdown.classList.add('dropdown');
        componentsDropdown.name = "component_dropdown";
        componentsDropdown.add(new Option("Select an asset...", -1));
        const svg = d3.select(document.getElementById("dfd")).select("svg");
        svg.selectAll(".node_group").each(function (d, i) {
            componentsDropdown.add(new Option(d3.select(this).select(".asset_label").text(), nodeIndex(d.id)))
        });
        newDiv.appendChild(componentsDropdown);

        // Create the remove button 
        var removeButton = document.createElement('button');
        removeButton.id = "remove_button";
        removeButton.setAttribute("type", "button");
        removeButton.classList.add("remove_button");
        removeButton.innerHTML = "-";
        removeButton.setAttribute('onclick', 'removeComponent();');
        newDiv.appendChild(removeButton);

        // Finally append everything to the existing dropdowns
        var addingWorkflows = document.getElementById('adding_workflows');
        addingWorkflows.append(newDiv);
    }

    // Defines how the remove button behaves
    function removeComponent() {
        // Remove the last asset dropdown
        var divs = document.getElementsByClassName("component_div")
        divs[divs.length - 1].remove();

        // Add back the remove button if there's still more than one dropdown
        if (divs.length > 0) {
            var removeButton = document.createElement('button');
            removeButton.id = "remove_button";
            removeButton.setAttribute("type", "button");
            removeButton.classList.add("remove_button");
            removeButton.innerHTML = "-";
            removeButton.setAttribute('onclick', 'removeComponent();');
            divs[divs.length - 1].appendChild(removeButton);
        }
    }

    // Adds a work flow between the chosen elements
    function addWorkFlow() {
        if (links.length < 1) {
            alert("Please add a data flow first!");
            return;
        }
        
        // Get the currently selected assets
        var comp_dropdowns = document.getElementsByName("component_dropdown");

        if (comp_dropdowns.length < 2) {
            alert("Please select at least two components to create a workflow!");
            return;
        }

        const components = [];

        for (let dropdown of comp_dropdowns) {
            // var component_dropdown = "component_dropdown" + i;
            // var selected = getDropdownValue(component_dropdown);
            var selected = dropdown.value;

            // Check that user has selected all components 
            if (selected == -1) {
                alert("Please make a selection for each component or remove components!");
                return;
            }
            // Check that user has not selected duplicate components 
            if (components.includes(nodes[selected].id)) {
                alert("Do not include more than one of the same component!");
                return; 
            }
            components.push(nodes[selected].id);
        }

        // Check that there's a dataflow between each element in the right order
        for (let i = 0; i < components.length - 1; i++) {
            if (!links.find(link => link.source.id === components[i] && link.target.id === components[i + 1])) {
                alert("There is no data flow from " + nodes[components[i]].asset_name + " to " + nodes[components[i + 1]].asset_name);
                return;
            };
        }

        // Prevent duplicate workflows
        for (let workflow of Object.values(workflows)) {
            if (components.length != workflow.length) {
                continue;
            }
            let check_duplicate = true;
            for (let i = 0; i < components.length; i++) {
                if (workflow[i] != components[i]) {
                    check_duplicate = false;
                    break;
                }
            }
            if (check_duplicate) {
                alert("Cannot add a duplicate workflow!");
                return;
            }
        }

        // Prompt user for workflow name...
        var workflow_name = window.prompt("(Optional) Name this workflow:", "");

        // Return from function if user cancels
        if (workflow_name === null || workflow_name === false)
            return;

        // Set default workflow name if user does not name it 
        if (workflow_name == "") {
            workflow_name = "Workflow " + (Object.keys(workflows).length + 1);
        }
        workflows[workflow_name] = components;

        // Update the bottom bar's workflow dropdown
        if (document.getElementById("workflow_dropdown")) {
            resetBottomBar();
        }

        // Update options button workflow list
        if (document.getElementById("view_workflow")) {
            var curr_asset = document.getElementById("options").children[0].value;
            document.getElementById("view_workflow").replaceChild(createWorkflowList(curr_asset), document.getElementById("workflow_button"));
        }
    }

    // Highlights the components of a workflow that the user selects to view
    function viewWorkflow() {
        // Check that user actually selects a workflow
        if (getDropdownValue("workflow_dropdown") == -1) {
            alert("Please select a workflow to view!");
            return;
        }

        let dropdown = document.getElementById("workflow_dropdown");
        var selectedWorkflow = dropdown.options[dropdown.selectedIndex].text;
        var components = workflows[selectedWorkflow];

        // Unselect any currently selected nodes
        for (let node of nodes) {
            node.selected = false;
        }
        d3.selectAll(".asset")
            .style("stroke", "black")
            .style("stroke-width", "1");
        
        // Selects and highlights the components of the workflow being viewed
        svg.selectAll(".node_group").each(function (d) {
            if (components.some(i => i == d.id)) {
                d3.select(this).selectAll(".asset")
                .style("stroke", "#3E8EDE")
                .style("stroke-width", "4");
            }
        });

        // Updates bottom bar to display order of components in workflow 
        let bottom_bar_html = "<h2>"+ selectedWorkflow +"</h2> <h3 style=\"font-weight:normal\">";
        for (let component of components) {
            bottom_bar_html += "<span style=\"cursor: pointer\" id=\"comp " + component + "\">" + nodes[nodeIndex(component)].asset_name + "</span>";
            if (component != components[components.length - 1]) {
                bottom_bar_html += " &#8594 ";
            }
        }
        bottom_bar_html += "</h3> <br> <button type=\"button\" class=\"unselect_button\" id=\"unselect_button\">Unselect Workflow</button>";
        bottom_bar_html += "<br> <button type=\"button\" class=\"remove_workflow\" id=\"remove_workflow\">Remove Workflow</button>";
        document.getElementById("bottom_bar").innerHTML = bottom_bar_html;
        var unselect_button = document.getElementById("unselect_button");
        unselect_button.onclick = function () {
            // Unselect all nodes
            for (let node of nodes) {
                node.selected = false;
            }
            d3.selectAll(".asset")
                .style("stroke", "black")
                .style("stroke-width", "1");
            resetBottomBar();
        }
        var remove_button = document.getElementById("remove_workflow");
        remove_button.onclick = function () {
            // Unselect all nodes
            for (let node of nodes) {
                node.selected = false;
            }
            d3.selectAll(".asset")
                .style("stroke", "black")
                .style("stroke-width", "1");
            delete workflows[selectedWorkflow];
            resetBottomBar();
        }

        // create buttons to select/view each asset in the workflow
        for (let component of components) {
            var compID = "comp " + component;
            document.getElementById(compID).onclick = function() {
                svg.selectAll(".node_group").filter(d => d.id === component).dispatch('click');
            };
        }
    }


    // Add a threat to an existing DFD node.
    function addThreat() {
        let asset = getDropdownValue("threat_dropdown");

        if (asset == -1) {
            alert("Please select an asset to add a threat to!");
            return;
        }

        let title = document.getElementById("threat_title").value
        if (title == "") {
            alert("Please add a threat title!");
            return;
        }
        let cve_num = document.getElementById("threat_number").value
        let description = document.getElementById("threat_description").value

        nodes[asset].threats.push({
            "threat_num": cve_num,
            "threat_title": title,
            "threat_description": description,
            "findings": null
        })

        alert("New threat (" + title + ") added to " + nodes[asset].asset_name + " succesfully!");

        let textboxes = document.getElementsByClassName("threat_textbox");
        for (let textbox of textboxes) {
            textbox.value = "";
        }

        // update list in details bar
        var options = document.getElementById("options");
        if (options && options.children[0].value == nodes[asset].id) {
            svg.selectAll(".node_group").filter(d => d.id === nodes[asset].id).dispatch('click').dispatch('click');
        }
    }

    // Add a control to an existing DFD node.
    // TODO: maybe merge this with addThreat()?
    function addControl() {
        let asset = getDropdownValue("controls_dropdown");

        if (asset == -1) {
            alert("Please select an asset to add a control to!");
            return;
        }

        let title = document.getElementById("control_title").value
        if (title == "") {
            alert("Please add a control title!");
            return;
        }
        let description = document.getElementById("control_description").value

        nodes[asset].controls.push({
            "control_title": title,
            "control_description": description
        })

        alert("New control (" + title + ") added to " + nodes[asset].asset_name + " succesfully!");

        let textboxes = document.getElementsByClassName("controls_textbox");
        for (let textbox of textboxes) {
            textbox.value = "";
        }

        // update list in details bar
        var options = document.getElementById("options");
        if (options && options.children[0].value == nodes[asset].id) {
            svg.selectAll(".node_group").filter(d => d.id === nodes[asset].id).dispatch('click').dispatch('click');
        }
    }

    // Gets values from radio buttons
    // Returns null if no value is selected (which throws an error later)
    function getTechImpactValue(impact_name) {
        let query = "input[name=\"radio_" + impact_name + "\"]:checked";
        let selection = document.querySelector(query);
        if (selection == null) {
            return null;
        }
        else {
            return selection.value;
        }
    }

    // Save any info filled into a findings page.
    function saveFinding() {
        let assessor_textbox = document.getElementById("assessor_textbox");

        if (assessor_textbox.value == "") {
            alert("Please add the name of the assessor(s) for this finding!");
            return;
        }

        let technical_impact = [
            getTechImpactValue("confidentiality"),
            getTechImpactValue("integrity"),
            getTechImpactValue("availability"),
            getTechImpactValue("authenticity"),
            getTechImpactValue("nonrepudiation"),
            getTechImpactValue("authorization"),
        ];
        for (let impact of technical_impact) {
            if (impact == null) {
                alert("Please set a technical impact level for each field!");
                return;
            }
        }

        let asset_index = getDropdownValue("findings_asset_dropdown");
        let threat_index = getDropdownValue("findings_threats_dropdown");

        let notes_textbox = document.getElementById("notes_textbox");
        var checked_boxes = document.querySelectorAll('input[name=control_checkbox]:checked');

        let findings = {
            "status": getDropdownValue("status_dropdown"),
            "controls": checked_boxes,
            "technical_impact": {
                "confidentiality": technical_impact[0],
                "integrity": technical_impact[1],
                "availability": technical_impact[2],
                "authenticity": technical_impact[3],
                "nonrepudiation": technical_impact[4],
                "authorization": technical_impact[5],
            },
            "harm": getDropdownValue("harm_dropdown"),
            "exploitability": getDropdownValue("exploitability_dropdown"),
            "assessor": assessor_textbox.value,
            "assessment_date": new Date(),
            "notes": notes_textbox.value,
        }

        nodes[asset_index].threats[threat_index].findings = findings
        console.log(nodes[asset_index].threats[threat_index].findings)

        alert("Findings saved!");
    }

    // TODO
    // Findings tab:
    // -- Pick an asset from a dropdown
    // -- Pick a threat on that asset from a dropdown
    //
    // -- See a list of checkboxes for all controls on that asset,
    //    with the ability to check which ones are mitigating that threat
    // -- Relevant? toggle
    // -- Technical impact section: One line per factor
    //    (confidentiality, integrity, availability, authenticity,
    //    non-repudiation, authorization)
    //    Each of these is set by user to None/Low/High (default None)
    // -- Safety impact section: One line per factor
    //    Harm: Unset/Negligible/Minor/Serious/Critical/Catastrophic
    //        (default Unset)
    //    Exploitability: Unknown/Low/Medium/High
    //        (default Unknown)
    //    Assessment Time: (autopopulated with current time)
    //    Assessed By: User can input their name
    // -- Additional Notes: User can add any other notes
    // -- User should be able to mark a finding as completed once they have
    //    been properly filled in (or un-mark completed if they think
    //    something needs to be changed)
    //
    // -- List of threats should be color-coded based on the status of their
    //    associated findings...:
    //    Red - Finding has been generated; is not complete
    //    Orange - Finding has been generated; some data is saved, not marked
    //        as complete
    //    Black - Finding is marked as complete
    //    Grey - Finding is marked as not relevant



</script>
</body>

</html>
